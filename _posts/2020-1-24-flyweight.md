---
layout: post
title: "享元模式"
date: 2020-1-24
description: "享元模式"
tag: 设计模式
---  

享元模式是池技术的重要实现方式。
#### 定义
> 使用共享对象可有效地支持大量的细粒度的对象。

这里有两个关键词：细粒度和共享的对象。为了避免细粒度导致的对象数量剧烈增加，享元模式对对象信息分为两部分：内部状态和外部状态。内部状态是对象可共享的信息，不随环境改变而改变。外部状态是对象得以依赖的一个标记，随环境改变而改变、不可共享。  
通用类图如下：  
![](/images/posts/designpattern/flyweight.png)  
类图中有这么几个角色：  
Flyweight抽象享元角色定义对象的外部状态和内部状态的接口或实现；  
ConcreteFlyweight具体享元角色实现具体业务，其中内部状态处理与环境无关；  
UnsharedConcreteFlyweight即不可共享的享元角色，是不存在外部状态或者安全要求（比如线程安全）不能使用共享技术的对象，一般不出现在享元工厂中。  
FlyweightFactory享元工厂就是池容器，提供获取对象的方法。

#### 优点
- 减少程序创建的对象，降低内存占用

#### 缺点
- 增加了系统复杂性

#### 使用场景
- 存在大量相似对象
- 细粒度外部状态较接近，且内部状态与环境无关
- 需要缓冲池时

#### 注意事项
- 线程安全
- 性能平衡，应尽量使用Java的基本类型

#### 享元模式和对象池的异同
享元模式可以实现对象池；但是对象池重点在于对象的复用，对上层调用来说从一个池中获取A对象还是B对象没有差别，而享元模式的重点是对象的共享，关注如何建立多个可共享的细粒度对象。

参考：
> 设计模式之禅